{
  "code_quality": [
    {
      "id": "cq-001",
      "type": "code_quality",
      "title": "Split monolithic ProjectTimeline component into smaller modules",
      "description": "The components/project-timeline.tsx file has grown to 761 lines and handles multiple responsibilities: timeline rendering, date calculations, project state management, task handling, dialogs, and both desktop/mobile views. This violates single responsibility principle and makes the code difficult to maintain and test.",
      "rationale": "A 761-line React component is a significant code smell. Large files increase cognitive load, make code reviews harder, lead to merge conflicts, and are nearly impossible to unit test properly. The component mixes UI rendering with business logic and state management.",
      "category": "large_files",
      "severity": "major",
      "affectedFiles": ["components/project-timeline.tsx"],
      "currentState": "Single 761-line file handling timeline header, project rows, task rows, date calculations, drag handlers, dialogs, zoom controls, and mobile view all in one component",
      "proposedChange": "Split into: 1) components/timeline/TimelineHeader.tsx (controls, zoom, navigation), 2) components/timeline/TimelineRow.tsx (project/task row rendering), 3) components/timeline/TimelineGrid.tsx (date grid rendering), 4) components/timeline/MobileTimeline.tsx (mobile view), 5) hooks/useTimelineState.ts (state management), 6) lib/timeline-utils.ts (date calculations)",
      "codeExample": "// Current: Everything in one file\nexport function ProjectTimeline() {\n  const [projects, setProjects] = useState(...);\n  // ... 700+ lines of mixed concerns\n}\n\n// Proposed: Separated concerns\n// hooks/useTimelineState.ts\nexport function useTimelineState(initialProjects: Project[]) {\n  const [projects, setProjects] = useState(initialProjects);\n  const handleUpdateProject = useCallback((id, newStart) => {...}, []);\n  return { projects, handleUpdateProject, ... };\n}\n\n// components/timeline/TimelineHeader.tsx\nexport function TimelineHeader({ viewMode, onViewModeChange, onNavigate, onZoom }) {...}\n\n// components/ProjectTimeline.tsx (orchestrator)\nexport function ProjectTimeline() {\n  const timeline = useTimelineState(initialProjects);\n  return (\n    <div>\n      <TimelineHeader {...controls} />\n      <TimelineGrid dates={dates} />\n      {projects.map(p => <TimelineRow key={p.id} project={p} />)}\n    </div>\n  );\n}",
      "bestPractice": "Single Responsibility Principle - each module should have one reason to change. React components should be small, focused, and composable.",
      "metrics": {
        "lineCount": 761,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "large",
      "breakingChange": false,
      "prerequisites": ["Ensure component renders correctly before refactoring", "Consider adding tests first to catch regressions"]
    },
    {
      "id": "cq-002",
      "type": "code_quality",
      "title": "Add ESLint and Prettier configuration for code consistency",
      "description": "The project lacks ESLint and Prettier configuration files. While a 'lint' script exists in package.json, there's no .eslintrc.* or .prettierrc file to enforce code style and catch potential issues. This leads to inconsistent code formatting and missed opportunities to catch bugs early.",
      "rationale": "Linting and formatting tools are essential for maintaining code quality in team environments. They catch potential bugs (unused variables, missing dependencies in useEffect, etc.), enforce consistent code style, and reduce code review friction. Next.js projects typically benefit from next/core-web-vitals and TypeScript-specific ESLint rules.",
      "category": "linting",
      "severity": "major",
      "affectedFiles": ["package.json"],
      "currentState": "No ESLint configuration file found. The lint script in package.json runs 'eslint .' but without explicit config, it relies on defaults or may not run effectively.",
      "proposedChange": "Create .eslintrc.json with Next.js recommended rules, TypeScript strict rules, and React hooks linting. Create .prettierrc for consistent formatting. Add lint-staged and husky for pre-commit hooks.",
      "codeExample": "// .eslintrc.json\n{\n  \"extends\": [\n    \"next/core-web-vitals\",\n    \"next/typescript\",\n    \"plugin:@typescript-eslint/recommended\"\n  ],\n  \"rules\": {\n    \"@typescript-eslint/no-unused-vars\": \"error\",\n    \"@typescript-eslint/no-explicit-any\": \"warn\",\n    \"react-hooks/exhaustive-deps\": \"warn\"\n  }\n}\n\n// .prettierrc\n{\n  \"semi\": false,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"es5\"\n}",
      "bestPractice": "Every TypeScript project should have proper linting configuration to catch issues early and maintain consistency.",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": ["Run linter after setup to identify existing issues"]
    },
    {
      "id": "cq-003",
      "type": "code_quality",
      "title": "Extract reusable GenericPicker and DatePicker to shared components",
      "description": "The GenericPicker and DatePicker components are defined in components/project-wizard/steps/StepQuickCreate.tsx but are imported and used by multiple files including TaskQuickCreateModal.tsx and StepOutcome.tsx. This creates an awkward dependency where shared UI components live inside a specific wizard step file.",
      "rationale": "Placing reusable components inside a feature-specific file violates the principle of proper module organization. It creates confusing import paths, makes the StepQuickCreate.tsx file larger than necessary (624 lines), and makes it harder to discover and maintain these shared components.",
      "category": "structure",
      "severity": "minor",
      "affectedFiles": [
        "components/project-wizard/steps/StepQuickCreate.tsx",
        "components/tasks/TaskQuickCreateModal.tsx",
        "components/project-wizard/steps/StepOutcome.tsx"
      ],
      "currentState": "GenericPicker and DatePicker are defined in StepQuickCreate.tsx (624 lines) and imported elsewhere via: import { GenericPicker, DatePicker } from '@/components/project-wizard/steps/StepQuickCreate'",
      "proposedChange": "Extract to dedicated files: 1) components/ui/generic-picker.tsx for GenericPicker, 2) components/ui/date-picker.tsx for DatePicker (enhanced version of the base calendar). Update imports in consuming files.",
      "codeExample": "// Current import in TaskQuickCreateModal.tsx:\nimport { GenericPicker, DatePicker } from '@/components/project-wizard/steps/StepQuickCreate'\n\n// Proposed structure:\n// components/ui/generic-picker.tsx\nexport function GenericPicker<T extends { id: string; label?: string; name?: string }>({...}) {...}\n\n// components/ui/date-picker.tsx  \nexport function DatePicker({ date, onSelect, trigger }: DatePickerProps) {...}\n\n// Updated imports:\nimport { GenericPicker } from '@/components/ui/generic-picker'\nimport { DatePicker } from '@/components/ui/date-picker'",
      "bestPractice": "Reusable UI components should live in a dedicated location (like components/ui/) with clear, intuitive import paths.",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": 85,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": null
    },
    {
      "id": "cq-004",
      "type": "code_quality",
      "title": "Add unit tests for critical server actions and utilities",
      "description": "The project has no test files in the source code (only in node_modules). Critical business logic in lib/actions/ (auth, organizations, projects, tasks, clients) and utility functions lack any test coverage. This makes refactoring risky and allows bugs to slip into production.",
      "rationale": "Server actions handle critical operations like authentication, data mutations, and business logic. Without tests, changes to these files could break functionality without immediate detection. The codebase has complex logic in actions like auth.ts (208 lines), tasks.ts (392 lines), and projects.ts (349 lines) that would benefit greatly from test coverage.",
      "category": "testing",
      "severity": "major",
      "affectedFiles": [
        "lib/actions/auth.ts",
        "lib/actions/tasks.ts",
        "lib/actions/projects.ts",
        "lib/actions/organizations.ts",
        "lib/actions/clients.ts",
        "lib/utils.ts"
      ],
      "currentState": "Zero test files in the project source. No testing framework configured (Jest, Vitest, or @testing-library).",
      "proposedChange": "1) Add Vitest as testing framework (fast, TypeScript-native), 2) Create __tests__/ directories alongside lib/actions/, 3) Write unit tests for server actions with mocked Supabase client, 4) Add test coverage for utility functions.",
      "codeExample": "// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\nimport react from '@vitejs/plugin-react'\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'node',\n    globals: true,\n    coverage: { reporter: ['text', 'html'] }\n  }\n})\n\n// lib/actions/__tests__/auth.test.ts\nimport { signIn, signUp, signOut } from '../auth'\nimport { vi, describe, it, expect } from 'vitest'\n\nvi.mock('@/lib/supabase/server', () => ({...}))\n\ndescribe('auth actions', () => {\n  it('signIn returns error for invalid credentials', async () => {\n    const result = await signIn({ email: '', password: '' })\n    expect(result.error).toBeDefined()\n  })\n})",
      "bestPractice": "Critical business logic should have unit test coverage. Server actions that handle auth, data mutations, and validation are prime candidates for testing.",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": 0
      },
      "estimatedEffort": "medium",
      "breakingChange": false,
      "prerequisites": ["Install vitest and @testing-library packages", "Configure test environment"]
    },
    {
      "id": "cq-005",
      "type": "code_quality",
      "title": "Migrate mock data files to Supabase queries and remove legacy data layer",
      "description": "The lib/data/ directory contains large mock data files (project-details.ts at 643 lines, projects.ts at 545 lines, clients.ts at 321 lines) that were intended as temporary placeholders. These files create confusion about the source of truth and duplicate data structures that now exist in Supabase. The codebase mixes mock data imports with real Supabase queries.",
      "rationale": "Maintaining two data layers (mock and real) leads to bugs, confusion, and wasted effort. Developers may accidentally use mock data in production or spend time updating mock data that should be fetched from the database. The lib/data/ files add over 1,500 lines of code that should eventually be deleted.",
      "category": "dead_code",
      "severity": "minor",
      "affectedFiles": [
        "lib/data/project-details.ts",
        "lib/data/projects.ts",
        "lib/data/clients.ts",
        "lib/data/sidebar.ts"
      ],
      "currentState": "Mock data files exist alongside real Supabase queries. Components like project-timeline.tsx import from mock data: import { projects } from '@/lib/data/projects'. The CLAUDE.md notes these are 'being migrated to Supabase queries' but migration is incomplete.",
      "proposedChange": "1) Complete migration of all data fetching to Supabase server actions, 2) Update components to use real data from actions/queries, 3) Move any necessary seed data to Supabase seed scripts, 4) Delete or archive lib/data/ files, 5) Update imports throughout codebase.",
      "codeExample": "// Current: components/project-timeline.tsx\nimport { projects as initialProjects } from '@/lib/data/projects'\nexport function ProjectTimeline() {\n  const [projects, setProjects] = useState(initialProjects)\n  // ...\n}\n\n// Proposed: Fetch real data from Supabase\nimport { getProjects } from '@/lib/actions/projects'\nexport async function ProjectTimeline() {\n  const { data: projects } = await getProjects()\n  return <ProjectTimelineClient initialProjects={projects ?? []} />\n}",
      "bestPractice": "Single source of truth for data. Avoid maintaining parallel data layers that can get out of sync.",
      "metrics": {
        "lineCount": 1509,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "medium",
      "breakingChange": true,
      "prerequisites": ["Ensure all Supabase tables and RLS policies are set up", "Verify server actions exist for all data needs", "Test data fetching in development"]
    }
  ],
  "metadata": {
    "filesAnalyzed": 156,
    "largeFilesFound": 12,
    "duplicateBlocksFound": 3,
    "lintingConfigured": false,
    "testsPresent": false,
    "generatedAt": "2026-01-22T20:15:00Z"
  }
}
