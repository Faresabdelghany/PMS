{
  "performance_optimizations": [
    {
      "id": "perf-001",
      "type": "performance_optimizations",
      "title": "Enable Next.js Image Optimization",
      "description": "The next.config.mjs has `images: { unoptimized: true }` which disables all built-in image optimization. This means images are served at full size regardless of device, causing slower load times on mobile and wasted bandwidth.",
      "rationale": "Next.js Image optimization provides automatic image resizing, format conversion (to WebP/AVIF), lazy loading, and responsive image generation. The current config bypasses all these benefits. The avatar images, logo, and any future images will load at full resolution.",
      "category": "bundle_size",
      "impact": "high",
      "affectedAreas": ["next.config.mjs", "components/app-sidebar.tsx", "components/projects/AvatarGroup.tsx"],
      "currentMetric": "All images served unoptimized at full resolution",
      "expectedImprovement": "40-70% reduction in image payload size, ~500ms faster LCP on mobile connections",
      "implementation": "1. Remove `images: { unoptimized: true }` from next.config.mjs\n2. Replace `<img>` tags with Next.js `<Image>` component\n3. Add width/height or fill props to Image components\n4. Configure image domains if using external images",
      "tradeoffs": "Requires replacing <img> tags with <Image> component; may need to configure image domains for external sources",
      "estimatedEffort": "small"
    },
    {
      "id": "perf-002",
      "type": "performance_optimizations",
      "title": "Parallelize sequential data fetching on page load",
      "description": "In app/page.tsx and other pages, database queries (getUserOrganizations, getProjects, getClients) are executed sequentially. After getting the organization ID, the projects and clients queries can be parallelized to reduce page load time.",
      "rationale": "Currently the page waits for organization fetch, then sequentially fetches projects, then clients. Since getProjects() and getClients() are independent once we have the org ID, running them with Promise.all() could cut data fetch time by 30-40%.",
      "category": "network",
      "impact": "medium",
      "affectedAreas": ["app/page.tsx", "app/tasks/page.tsx", "app/clients/page.tsx"],
      "currentMetric": "Sequential waterfall: ~150-300ms for 3 queries",
      "expectedImprovement": "Parallel execution: ~100-200ms total (30-40% faster page load)",
      "implementation": "1. Keep getUserOrganizations() as first await (needed for org ID)\n2. Replace sequential getProjects() and getClients() with:\n   const [projectsResult, clientsResult] = await Promise.all([\n     getProjects(organization.id),\n     getClients(organization.id)\n   ])\n3. Apply same pattern to app/tasks/page.tsx where multiple data fetches occur",
      "tradeoffs": "Slightly more complex error handling for parallel operations",
      "estimatedEffort": "trivial"
    },
    {
      "id": "perf-003",
      "type": "performance_optimizations",
      "title": "Add composite database indexes for common query patterns",
      "description": "The database schema has individual column indexes but lacks composite indexes for multi-column query patterns. The tasks table is queried with (project_id, status), (assignee_id, status), and (project_id, workstream_id, sort_order) filters that would benefit from composite indexes.",
      "rationale": "Current queries on tasks/projects filter by multiple columns but only have single-column indexes. PostgreSQL must perform index intersection or table scans. Composite indexes allow index-only scans for these common patterns, significantly improving query performance.",
      "category": "database",
      "impact": "high",
      "affectedAreas": ["supabase/migrations/", "lib/actions/tasks.ts", "lib/actions/projects.ts"],
      "currentMetric": "Individual column indexes require intersection operations",
      "expectedImprovement": "2-5x faster filtered queries on tasks and projects tables",
      "implementation": "1. Create new migration file:\n   CREATE INDEX idx_tasks_project_status ON tasks(project_id, status);\n   CREATE INDEX idx_tasks_assignee_status ON tasks(assignee_id, status);\n   CREATE INDEX idx_tasks_project_workstream_order ON tasks(project_id, workstream_id, sort_order);\n   CREATE INDEX idx_projects_org_status ON projects(organization_id, status);\n2. Run npx supabase db push\n3. Monitor query performance in Supabase dashboard",
      "tradeoffs": "Slightly increased write overhead and storage for maintaining additional indexes (~5-10% more storage)",
      "estimatedEffort": "small"
    },
    {
      "id": "perf-004",
      "type": "performance_optimizations",
      "title": "Optimize getMyTasks to filter by organization at database level",
      "description": "The getMyTasks function fetches ALL tasks for a user, then filters by organization client-side with JavaScript. This wastes bandwidth and processing by over-fetching data across all organizations.",
      "rationale": "The function runs: `data.filter((task) => task.project?.organization_id === orgId)` after fetching. For users in multiple organizations, this fetches and discards unnecessary data. Supabase can filter via join condition: `.eq('project.organization_id', orgId)` using the !inner join modifier.",
      "category": "database",
      "impact": "medium",
      "affectedAreas": ["lib/actions/tasks.ts"],
      "currentMetric": "Over-fetching tasks from all organizations, then filtering client-side",
      "expectedImprovement": "50-80% reduction in data transfer for multi-org users; faster response times",
      "implementation": "1. Update the Supabase query in getMyTasks:\n   let query = supabase\n     .from('tasks')\n     .select(`\n       *,\n       assignee:profiles(...),\n       workstream:workstreams(...),\n       project:projects!inner(id, name, organization_id)\n     `)\n     .eq('assignee_id', user.id)\n     .eq('project.organization_id', orgId)\n2. Remove the client-side filteredData filter\n3. Return data directly instead of filteredData",
      "tradeoffs": "None significant - this is a pure optimization with no downsides",
      "estimatedEffort": "trivial"
    },
    {
      "id": "perf-005",
      "type": "performance_optimizations",
      "title": "Consolidate duplicate icon libraries to reduce bundle size",
      "description": "The project uses both @phosphor-icons/react (30+ files) and lucide-react (7 files) simultaneously. This adds ~50KB unnecessary bundle size. Consolidating to a single library would improve bundle size and maintainability.",
      "rationale": "@phosphor-icons/react is used in 30+ component files for primary icons via the optimized /dist/ssr path. lucide-react is only used in UI components (dialog, calendar, select, command) and settings pages. Migrating the 7 lucide-react usages to Phosphor icons eliminates the duplicate dependency.",
      "category": "bundle_size",
      "impact": "medium",
      "affectedAreas": ["components/ui/dialog.tsx", "components/ui/calendar.tsx", "components/ui/select.tsx", "components/ui/command.tsx", "app/invite/[token]/page.tsx", "app/(dashboard)/settings/profile/page.tsx", "app/(dashboard)/settings/organization/page.tsx", "package.json"],
      "currentMetric": "Two icon libraries in bundle adding ~50-80KB overhead",
      "expectedImprovement": "~30-50KB reduction in bundle size, simpler consistent icon imports",
      "implementation": "1. Find Phosphor equivalents: XIcon→X, ChevronDown→CaretDown, ChevronUp→CaretUp, Check→Check, SearchIcon→MagnifyingGlass, Loader2→CircleNotch, CheckCircle→CheckCircle, XCircle→XCircle, AlertCircle→Warning, UserPlus→UserPlus, Trash2→Trash, Mail→Envelope\n2. Update imports to use @phosphor-icons/react/dist/ssr\n3. Test visual consistency\n4. Remove lucide-react from package.json\n5. Run pnpm install",
      "tradeoffs": "Minor visual differences between icon sets may require adjustment; one-time migration effort",
      "estimatedEffort": "small"
    }
  ],
  "metadata": {
    "totalBundleSize": "Estimated 2.5-3MB (unminified) based on dependencies",
    "largestDependencies": [
      "react-dom (~130KB)",
      "@tiptap/* (~200KB combined)",
      "recharts (~150KB)",
      "motion (~100KB)",
      "@dnd-kit/* (~80KB combined)",
      "@radix-ui/* (~60KB combined)",
      "@phosphor-icons/react (~40KB)",
      "lucide-react (~50KB)"
    ],
    "filesAnalyzed": 95,
    "potentialSavings": "~100-150KB bundle reduction, 30-40% faster page loads, 2-5x faster filtered queries",
    "generatedAt": "2026-01-22T20:20:00Z",
    "analysisNotes": [
      "Project uses modern React 19 with Next.js 16 App Router",
      "Good use of useMemo for filtering and computed values",
      "Sequential data fetching could be parallelized on page load",
      "Database missing composite indexes for common query patterns",
      "getMyTasks over-fetches data and filters client-side",
      "Duplicate icon libraries adding unnecessary bundle weight"
    ]
  }
}
